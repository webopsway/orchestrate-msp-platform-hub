import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface ScanRequest {
  cloud_asset_id: string;
  team_id: string;
  software_list?: string[];
}

interface CVEData {
  id: string;
  description: string;
  severity: string;
  published: string;
  modified: string;
  references: string[];
}

const handler = async (req: Request): Promise<Response> => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    // Get user from token
    const { data: { user }, error: authError } = await supabase.auth.getUser(
      authHeader.replace('Bearer ', '')
    );

    if (authError || !user) {
      throw new Error('Invalid authentication');
    }

    const url = new URL(req.url);
    const action = url.searchParams.get('action') || 'scan';

    if (action === 'scan') {
      const body: ScanRequest = await req.json();
      
      console.log('Starting vulnerability scan for asset:', body.cloud_asset_id);

      // Validate the cloud asset exists and user has access
      const { data: asset, error: assetError } = await supabase
        .from('cloud_asset')
        .select('*')
        .eq('id', body.cloud_asset_id)
        .single();

      if (assetError || !asset) {
        throw new Error('Cloud asset not found or access denied');
      }

      // Get software list from asset metadata or request
      const softwareList = body.software_list || asset.metadata?.software || [
        'nginx', 'apache', 'mysql', 'postgresql', 'redis', 'docker'
      ];

      console.log('Scanning software:', softwareList);

      const vulnerabilities: CVEData[] = [];

      // Scan each software for vulnerabilities using NIST NVD API
      for (const software of softwareList) {
        try {
          console.log(`Scanning vulnerabilities for ${software}...`);
          
          // NIST NVD API (free tier - limited requests)
          const nvdUrl = `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${software}&resultsPerPage=5`;
          
          const nvdResponse = await fetch(nvdUrl, {
            headers: {
              'User-Agent': 'Supabase-Security-Scanner/1.0',
            }
          });

          if (!nvdResponse.ok) {
            console.warn(`NVD API request failed for ${software}:`, nvdResponse.status);
            continue;
          }

          const nvdData = await nvdResponse.json();
          
          if (nvdData.vulnerabilities && nvdData.vulnerabilities.length > 0) {
            for (const vuln of nvdData.vulnerabilities.slice(0, 3)) { // Limit to 3 per software
              const cve = vuln.cve;
              
              // Extract severity (CVSS v3 or v2)
              let severity = 'medium';
              if (cve.metrics?.cvssMetricV31?.[0]) {
                const score = cve.metrics.cvssMetricV31[0].cvssData.baseScore;
                if (score >= 9.0) severity = 'critical';
                else if (score >= 7.0) severity = 'high';
                else if (score >= 4.0) severity = 'medium';
                else severity = 'low';
              } else if (cve.metrics?.cvssMetricV30?.[0]) {
                const score = cve.metrics.cvssMetricV30[0].cvssData.baseScore;
                if (score >= 9.0) severity = 'critical';
                else if (score >= 7.0) severity = 'high';
                else if (score >= 4.0) severity = 'medium';
                else severity = 'low';
              }

              vulnerabilities.push({
                id: cve.id,
                description: cve.descriptions?.[0]?.value || 'No description available',
                severity,
                published: cve.published,
                modified: cve.lastModified,
                references: cve.references?.map((ref: any) => ref.url) || []
              });
            }
          }

          // Rate limiting to avoid hitting API limits
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (scanError) {
          console.error(`Error scanning ${software}:`, scanError);
        }
      }

      console.log(`Found ${vulnerabilities.length} vulnerabilities`);

      // Store vulnerabilities in database
      const storedVulnerabilities = [];
      
      for (const vuln of vulnerabilities) {
        try {
          // Check if vulnerability already exists
          const { data: existingVuln } = await supabase
            .from('security_vulnerabilities')
            .select('id')
            .eq('cve_id', vuln.id)
            .eq('cloud_asset_id', body.cloud_asset_id)
            .single();

          if (!existingVuln) {
            // Create new vulnerability record
            const { data: newVuln, error: vulnError } = await supabase
              .from('security_vulnerabilities')
              .insert({
                title: `CVE: ${vuln.id}`,
                description: vuln.description,
                cve_id: vuln.id,
                severity: vuln.severity,
                status: 'open',
                cloud_asset_id: body.cloud_asset_id,
                team_id: body.team_id,
                discovered_at: new Date().toISOString(),
                metadata: {
                  published: vuln.published,
                  modified: vuln.modified,
                  references: vuln.references,
                  scanner: 'nvd-api',
                  auto_detected: true
                }
              })
              .select()
              .single();

            if (!vulnError && newVuln) {
              storedVulnerabilities.push(newVuln);
              console.log('Created vulnerability record:', newVuln.id);
            }
          }
        } catch (storeError) {
          console.error('Error storing vulnerability:', storeError);
        }
      }

      // Update asset last scan time
      await supabase
        .from('cloud_asset')
        .update({ last_scan: new Date().toISOString() })
        .eq('id', body.cloud_asset_id);

      return new Response(
        JSON.stringify({
          success: true,
          message: 'Vulnerability scan completed',
          vulnerabilities_found: vulnerabilities.length,
          vulnerabilities_stored: storedVulnerabilities.length,
          asset_id: body.cloud_asset_id
        }),
        {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        }
      );

    } else if (action === 'check-overdue-remediation') {
      // Check for overdue vulnerability remediation
      console.log('Checking for overdue vulnerability remediation...');

      // Get vulnerabilities older than defined thresholds
      const now = new Date();
      const criticalThreshold = new Date(now.getTime() - (24 * 60 * 60 * 1000)); // 1 day
      const highThreshold = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000)); // 7 days
      const mediumThreshold = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000)); // 30 days

      const { data: overdueVulns, error: overdueError } = await supabase
        .from('security_vulnerabilities')
        .select('*, cloud_asset(*)')
        .eq('status', 'open')
        .or(
          `and(severity.eq.critical,discovered_at.lt.${criticalThreshold.toISOString()}),and(severity.eq.high,discovered_at.lt.${highThreshold.toISOString()}),and(severity.eq.medium,discovered_at.lt.${mediumThreshold.toISOString()})`
        );

      if (overdueError) {
        throw new Error('Failed to check overdue vulnerabilities');
      }

      const alerts = [];

      for (const vuln of overdueVulns || []) {
        // Create monitoring alert for overdue vulnerability
        const daysSinceDiscovery = Math.round((Date.now() - Date.parse(vuln.discovered_at)) / (1000 * 60 * 60 * 24));
        
        const { error: alertError } = await supabase
          .from('monitoring_alerts')
          .insert({
            alert_name: 'Overdue Vulnerability Remediation',
            alert_type: 'security',
            severity: vuln.severity === 'critical' ? 'critical' : 'high',
            message: `Vulnerability ${vuln.cve_id} on ${vuln.cloud_asset?.asset_name} requires immediate attention. Discovered ${daysSinceDiscovery} days ago.`,
            team_id: vuln.team_id,
            metadata: {
              vulnerability_id: vuln.id,
              cve_id: vuln.cve_id,
              cloud_asset_id: vuln.cloud_asset_id,
              days_overdue: daysSinceDiscovery,
              severity: vuln.severity
            }
          });

        if (!alertError) {
          alerts.push(vuln.id);
        }
      }

      return new Response(
        JSON.stringify({
          success: true,
          overdue_vulnerabilities: overdueVulns?.length || 0,
          alerts_created: alerts.length
        }),
        {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        }
      );

    } else {
      throw new Error('Invalid action parameter');
    }

  } catch (error: any) {
    console.error('Error in vulnerability-scanner:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      }
    );
  }
};

serve(handler);